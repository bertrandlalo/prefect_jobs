==========
Guidelines
==========

As we extend Iguazu with more pipelines, we converge towards well-defined
rules and notation throughout all our tasks, functions or flows, etc.

Separation of concerns
======================

In Iguazu, there are functions, tasks and flows.
Separation of concerns will help us organize our code.

Please read the complete explanation of these :ref:`Key concepts` to understand
their nuances.

Unit of parallelization
=======================

The *preferred* unit of parallelization is the *file*. A common unit of
parallelization will homogenize the structure of our flows.

In general, tasks and flows are designed to work on several files in parallel.

There are some exceptions to this guideline. For example, when one expects a
file so large that it would be more efficient to parallelize over its contents.

Data exchange
=============

Tasks receive and send *reference to files*. A small data exchange footprint
will reduce the amount of data transmission on our cluster.

A reference to a file can be a path (when using local data) or an identifier
(when using remote data through Quetzal). The :py:mod:`iguazu.helpers.files`
module provides abstractions for these objects.

There are some exceptions to this guideline, mostly related to the exceptions
noted in `Unit of parallelization`_.

.. _rule_file_format:

File format
===========

When saving derived data or results, the *preferred* file format to save
dataframe-like data is HDF5. Refer to the :ref:`hdf5` page for more details.

There are exceptions, where dataframes are not the intended result. For example,
when generating a HTML report. For these cases, there are no guidelines yet.

Empty results
=============

An empty result is a file with no contents, with a size of 0 bytes.

This does not apply when a task does not generate a file, an exception noted in
the `Unit of parallelization`_ and `Data exchange`_ rules.

Metadata
========

Every file generated by Iguazu has metadata associated to it.

Quetzal manages this metadata when working on remote datasets, while local
datasets are handled with JSON files. Since Quetzal organizes metadata in
families, the appropriate family name is ``"iguazu"``.

The strict minimum metadata of a file generated by Iguazu must have the following keys:

=============== ==================================================== =================================
Name            Description                                          Examples
=============== ==================================================== =================================
``created_by``   | Name of the program that generated this file.      | Always ``"iguazu"``.
--------------- ---------------------------------------------------- ---------------------------------
``task``         | Fully qualified name of the Iguazu task that       | ``iguazu.tasks.foo.BarTask``.
                 | generated this file.
--------------- ---------------------------------------------------- ---------------------------------
``version``      | Version of Iguazu (or from the task) in            | ``1.0.2``.
                 | SemVer_ format.
--------------- ---------------------------------------------------- ---------------------------------
``status``       | Status of the task that generated this file        | ``"SUCCESS"`` or ``"FAILED"``.
--------------- ---------------------------------------------------- ---------------------------------
``problem``      | An object with details on the error that occurred  | See below
                 | during the execution of the task that generated
                 | this file. This object follows a JSON `RFC-7807`_
                 | structure. When a file has been generated without
                 | any error, this field can be ``null``.
=============== ==================================================== =================================

An example metadata entry for a file with id
``00000000-0000-4000-8000-000000000000`` could have the following metadata:

.. code-block:: json

  {
    "base" : {
      "id": "00000000-0000-4000-8000-000000000000",
      "filename": "foo.hdf5",
      "path": "study/p000",
      "size": 1024
    },
    "iguazu": {
      "created_by": "iguazu",
      "task": "iguazu.tasks.preprocess.Remove50Hz",
      "version": "0.1.0",
      "status", "FAILED",
      "problem": {
        "title": "Sampling rate must be > 100 Hz",
        "type": "iguazu.core.exceptions.SoftPreconditionFailed",
        "detail": "... a backtrace ..."
      }
    }
  }

Failures
========

A task can fail in two ways: a soft or a hard failure.

Soft failures (or graceful failures) refer to situations when the task
encounters a known problem that should can still generate a result. For example,
a filtering task that receives an empty signal could soft fail in this case,
and generate an empty signal as a result.

Soft failures can generate results. They may be `Empty results`_, but could
be a file with some other default contents.

Hard failures, refer to situations that were unexpected for the task. They
should be reported (automatically) and the any task that depends on the results
of the failed task should not be executed. For example, when a task fails to
download the file that it needs to process (because Quetzal is down or the
network connection failed): this is a hard fail; the task should
not generate a false result just because it could not read the input correctly
due to an external problem.

Hard failures do not generate results. Not even `Empty results`_.

Preconditions
=============

Task should verify any precondition prior to doing its work. When a precondition
is not met, it can choose to hard or soft fail. Use preconditions as safeguards
to your task code.

For example, a task that cleans a signal by using a band-pass filter may want
to verify that the input signal does not have holes in the data (this should
probably be handled beforehand). Depending on the case, this could be a hard
or soft fail.

Postcondition
=============

Like preconditions, tasks should verify any postcondition prior to finishing
up their work. When a postcondition is not met, it can choose to hard or soft
fail, but it makes more sense to hard fail. Use postconditions as safeguards
on your task code.

For example, a task that converts a file from a format to another could verify
that the target format is respected. If the format is not valid, it is better
to fail early than to debug a failure on the downstream tasks.

Task caching
============

To-define: what kind of caches are we using? Prefect cache? Our own
metadata-based and content-based cache? (I personally would prefer the former
but it may not meet all of our needs). When should we cache? What is force?

Plots
=====

To define later:

One task one plot? vs One plot per flow.

Task parameters
===============

What goes in the constructor, on the run method, or on the prefect context?

What is changeable by command-line?


.. _SemVer: https://semver.org
.. _`RFC-7807`: https://tools.ietf.org/html/rfc7807
